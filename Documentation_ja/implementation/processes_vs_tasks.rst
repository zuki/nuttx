==============================
Linuxのプロセス対NuttXのタスク
==============================

LinuxやWindowsでファイルに保存されたプログラムを実行することに慣れているかもしれません。
限られたリソースしかないMCUでNuttXタスクを使うと動作の違いに築くことなります。
このWikiページではそれらの違いをいくつかまとめています。

NuttXのビルドタイプ
=====================

NuttXはいくつかの方法でビルドすることができます。

* **カーネルビルド** カーネルビルドは ``CONFIG_BUILD_KERNEL`` で選択され、MCUの
  メモリ管理ユニット (MMU) を使い、Linuxのプロセスによく似たプロセスを実装しています。
  ここでは興味深い議論はありません。NuttXはLinuxと非常によく似た動作をします。

* **フラットビルド** リソースに制限のあるほとんどのMCUはMMUを持っておらず、コードは
  オンチップFLASHメモリの保護されていないフラットなアドレス空間で実行されるブロブと
  してビルドされます。このビルドモードは ``CONFIG_BUILD_FLAT`` で選択され、NuttXを
  ビルドする最も一般的な方法です。これはこのWikiページが対象としている興味深いケースです。

* **プロテクトビルド** もう一つのビルドオプションはプロテクトビルドです。これは
  基本的にフラットビルドと同じですが、MCUのメモリ保護ユニット (MPU) を使い、保護されて
  いないユーザアドレス範囲と保護されているシステムアドレス範囲を分離します。このWiki
  ページのコメントはこの場合にも適用されます。

グローバル変数の初期化
==================================

Linuxの振る舞い
----------------

Linuxのプログラムを書くのに慣れている人であれば、グローバル変数はシステムの起動時に
一度だけ初期化されることに気づくだろう。たとえば 次の小さなプログラムを考えてみます。

.. code-block:: C
                
   bool test = true;
 
   int main(int argc, char **argv)
   {
     printf("test: %i\n", test);
     test = false;
     printf("test: %i\n", test);
     return 0;
   }

このプログラムをinuxでビルド・実行すると次のような出力になります:

  test: 1
  test: 0

この場合、グローバル変数はファイルをメモリにロードして実行するたびに最初期化されます。

フラットビルドしたNuttXの振る舞い
----------------------------------

しかし、このプログラムをオンチップFLASH上でビルドし、(``task_start()`` 経由で)タスクと
して起動すると、プログラムを最初に起動した際は次の結果となります:

  test: 1
  test: 0

しかし、その後は常に次の結果となります::

  test: 0
  test: 0

変数testは電源投入時に一度だけtrue (1) に初期化されますが、プログラムが実行されるたびに
false (0) にリセットされます。

共通FLASHブロブに組み込んだ際にプログラムに同じ動作をさせたい場合はプログラムが実行
されるたびにグローバル変数が明示的にリセットされるようにコードを修正する必要があります:

.. code-block:: C

   bool test;
   
   int main(int argc, char **argv)
   {
     test = true;
     printf("test: %i\n", test);
     test = false;
     printf("test: %i\n", test);
     return 0;
   }

NuttXのローダブルプログラム
----------------------------

LinuxのようにプログラムをファイルからRAMにロードして実行するとNuttXはLinuxのように
動作します。フラットビルドのNuttXも同じように動作するからです。ファイルにあるNuttX ELF、
または、NxFLATモジュールを実行するとそのファイルはRAMにコピーされ、グローバル変数は
プログラムが実行される前に初期化されます。

しかし、FLASHに組み込まれているコードの動作は異なります。グローバル変数は1組しか存在
しません。モノリシックなFLASHイメージであるブロブ用のすべてのグローバル変数です。
これらはすべて電源リセット時に一度初期化されます。

これがLinuxアプリケーションをFLASHブロブへ移植するのを複雑にしている要因の1つです。
タスクを起動するたびに ``main()`` 内で各グローバル変数を手動で初期化しなければなりません。

グローバル変数と複数のタスクコピー
=========================================

フラットビルドコンテキストでのグローバル変数の使用はその使用に別の制限（ある時点で
実行可能なプログラムのコピーは１つだけ）も加わるため、可能な限り避けた方がよいです。
これはグローバル変数が各インスタンスで共有されるためです（繰り返しますが、各グローバル
変数のプライベートコピーが存在するファイルからプログラムを実行する場合とは異なります）。

in-FLASHプログラムで複数コピーをサポートする1つの方法はすべてのグローバル変数を構造体に
移動することです。グローバル変数に必要なメモリ量が少なければ ``main()`` ごとにその
構造体のコピーをスタックに割り当てるだけで良いでしょう。上の単純な例では次のように
なります:

.. code-block:: C

   struct my_globals_s
   {
     bool test;
   };
 
   int main(int argc, char **argv)
   {
     struct my_globals_s my_globals = { true };
 
     printf("test: %i\n", my_globals.test);
     my_globals.test = false;
     printf("test: %i\n", my_globals.test);
     return EXIT_SUCCESS;
   }

この場合、グローバル変数へのアクセスが必要な内部関数にはそのグローバル変数を割り当てた
構造体へのポインタをパラメータとして渡さなければならなくなります。したがって、内部関数を
次のように変更することになります:

.. code-block:: C

   static void print_value(void)
   {
     printf("test: %i\n", test);
   }

を次のように変更します::

.. code-block:: C

   static void print_value(FAR struct my_globals_s *globals)
   {
     printf("test: %i\n", globals->test);
   }

そして、この関数を呼び出すたびに割り当てたグローバル変数構造体への参照を渡します:

.. code-block:: C

   print_value(&my_globals);

グローバル変数構造体のサイズが大きい場合はスタック上にインスタンスを割り当てるのは
あまり良いアイデアではないかもしれません。そのような場合は ``malloc()`` を使用して
グローバル変数構造体を割り当てる方が良いかもしれません。ただし、終了する前に割り当てた
変数構造を ``free()`` することを忘れないでください（次節のメモリのクリーンアップの説明を
参照）。

.. code-block:: C

   struct my_globals_s
   {
     bool test;
   };
 
   int main(int argc, char **argv)
   {
     FAR struct my_globals_s *my_globals;
 
     my_globals = (FAR struct my_globals_s *)malloc(sizeof(struct my_globals_s));
     if (my_globals = NULL)
       {
         fprintf(stderr, "ERROR: Failed to allocate state structure\n");
         return EXIT_FAILURE;
       }
 
     my_globals=>test = true;
     printf("test: %i\n", my_globals->test);
     my_globals=>test = false;
     printf("test: %i\n", my_globals->test);
 
     free(my_globals);
     return EXIT_SUCCESS;
   }

メモリのクリーンアップ
======================

Linuxのプロセス終了
--------------------

もうひとつ、LinuxプログラムをFLASHブロブに移植する際には関係ないことですが、メモリの
クリーンアップがあります。Linuxプロセスは終了すると割り当てられたメモリーを含む
アドレス環境全体が破棄されます。次の小さなプログラムはLinuxプロセスとして実装された
すればメモリをリークすることはありません。

.. code-block:: C

   int main(int argc, char **argv)
   {
     char *buffer = malloc(1024);
     ... do stuff with buffer ...
     return 0;
   }

同じプログラムをFLASHブロブに移植した場合はメモリリークが発生します。タスク終了時に
割り当てられたメモリが自動的にクリーンアップされないからです。次のようにすべての
割り当て済みメモリは明示的に解放してクリーンアップする必要があります:
.. code-block:: C

   int main(int argc, char **argv)
   {
     char *buffer = malloc(1024);
     ... do stuff with buffer ...
     free(buffer);
     return 0;
   }

Linuxのプロセス終了時のメモリクリーンアップはプロセス終了時のプロセスアドレス環境
破棄の結果です。各プロセスには各自ヒープを持っています。プロセスアドレス環境が破棄
されるとプロセスのヒープはOSのページアロケータに返されます。そのため、メモリの
クリーンアップは基本的に自動で行われます。

NuttXのタスク終了
------------------

しかし、モノリシックなオンチップFLASHブロブのタスクを実行すると、同じヒープを他の
すべてのタスクと共有することになります。共通ヒープ内であなたのタスクで割り当てた
ヒープを見つけて解放するような魔法のクリーンアップはありません（「タスク終了時に
メモリを解放する方法」を参照）。

NuttXのプロセス終了
--------------------

(``CONFIG_BUILD_KERNEL`` を指定して)NuttX上でプロセスを実行する場合、 NuttXは
Linuxと同じように動作することに注意してください。アドレス環境はタスクの終了と共に
破棄され、すべてのメモリが回収されます。しかし、その他の場合はメモリリークします。

タスク終了時にメモリを解放する方法
-----------------------------------

割り当てられたメモリをタスクに関連付け、タスク終了時にクリーンアップする方法は
あります。ただし、この方法は却下されました。なぜなら、(1) 確実には実行できない、
(2) メモリ割り当てのオーバーヘッドが増え、これはメモリが制約されている状況では
受け入れられないからです。

関連する問題は `Github <https://github.com/apache/nuttx/issues/3345>`_ で見ることが
できます。
