=================
OSドライバの設計
=================

OSにより認識され、アプリケーションから見えるドライバには3種類があります。
2つはPOSIX標準のデバイスドライバであり、もう1つは非標準なドライバです。
また、OSの内部コンポーネントにもドライバとみなされるもの、もっと正確にいえば、
下半分ドライバがあります。これらの詳細は後述します。

キャラクタドライバとブロックドライバ
======================================

標準ドライバは以下の通りです：

* **キャラクタドライバ** まず、キャラクタドライバです。これは ``read()`` や ``write()`` などに
  よりユーザアクセシビリティをサポートするドライバです。その他は当然ながらサポートしません。
  キャラクタドライバは入出力バイトのストリームを実装しています。

* **ブロックドライバ** キャラクタストリームではなく、ブロック指向のI/Oをサポートする
  ファイルシステムのサポートに使用されます。ユーザはブロックドライバに *直接* アクセスすることは
  できません。

ただし、ユーザはキャラクタドライバプロキシを通じて間接的にブロックドライバにアクセスすることは
できます。キャラクタドライバもブロックドライバも、通常は ``/dev`` にあるデバイスノードにより
表されます。しかし、ブロックドライバを開こうとすると、非常に奇妙なことが起こります。つまり、
一時的で名前のないプロキシキャラクタドライバーが自動的にインスタンス化され、これがキャラクタ
ドライバのバイトストリームをブロックにマッピングし、ブロックドライバへのドライバアクセスを
仲介します。これが ``drivers/bch`` のロジックです。BCHは"block to character"を意味します。
したがって、アプリケーションから見るとどちらもキャラクタドライバに見え、アプリケーションは
両者と同じ方法でやりとりできます。

この機能は、たとえば、ブロックドライバでFATシステムをフォーマットする mkfatfs のようなNuttX
ファイルシステムフォーマットアプリケーションに見ることができます。

これと逆の、キャラクタドライバをブロックドライバに変換するループデバイスもあります。
通常、ループデバイスはRAM上にファイルシステムイメージをフォーマットするために使われます。

MTDドライバ
===========

非標準ドライバは

* **メモリー・テクノロジー・ドライバー（MTD）** です。この名前は ``infradead.org`` から
  拝借したものですがそのMTDロジックに由来するものではありません。MTDドライバはFLASHや
  EEPROMのようなメモリベースのデバイスを管理します。MTDのFLASHメモリドライバはブロック
  ドライバに非常に似ていますがFLASHにはいくつか異なる特性があります。特に、FLASHは書き
  込み前に消去する必要があります。

MTDにはブロックドライバと同じ便利さがあります。 ``/dev`` の下にデバイスノードとして表示
され、キャラクタドライバとしてオープンされた場合はキャラクタドライバとして動作するように
プロキシされます。さらに、MTDにはいくつかの利点があります。 MTDドライバは別のドライバの
上に重ねることで低レベルMTDドライバの機能を拡張することができます。たとえば、
``drivers/mtd/sector512.c`` はMTDドライバですが別の MTD ドライバの上に重ねると、FLASHの
見かけ上のページサイズを512バイトに変更します。

``drivers/mtd/mtd_partitions.c`` を使うと大きなFLASHを独立したパーティションに分割する
ことができ、各パーティションは別のMTDドライバのように見えます。

``drivers/mtd/ftl.c`` も興味深いものです。FTLはFLASH Translation Layerの略です。FTLドライバは
MTDドライバであり、別のMTDドライバの上に重ねることで、MTDドライバをブロックドライバに
変換します。組み合わせは無限です。

モノリシックドライバ
=======================

人はOSのデバイスドライバについて考える際、単一のもの、つまり、これら2つの主要なインタフェースを
持つブロック図の一つのブロックを思い浮かべます。

* デバイスモノリシックドライバは一つの標準デバイスドライバインタフェースを公開します。
  **仮想ファイル・システム (VFS)**により、これはドライバ機能へのAPI (application user 
  interface) を提供します。また、

* デバイスドライバにより管理されるハードウェアへの低レベルインタフェースも提供します。

上半分ドライバと下半分ドライバ
=================================

NuttXは非常に多くのMCUプラットフォームをサポートしており、それぞれは多くの似ているが
異なるペリフェラルを内蔵しています。確かにこのようなペリフェラルのそれぞれが前段落で
説明したモノリシックドライバでサポートされるような現実も想像できます。しかし、それでは
多くのコードが重複することになります。MCUペリフェラルは低レベルのレジスタレベルの
インタフェースではユニークかもしれません。しかし、抽象度の高いレベルではこれらの
ペリフェラルは非常によく似ています。

NuttXは **上半分** ドライバと **下半分** ドライバの概念を用いて、コードとドライバ開発、
双方の重複を減らしています。このような実装の結果、システムブロック図には2つのブロックが
存在します。共通の共有ドライバ群に含まれる上半分ドライバとMCU固有の下半分ドライバです。

前述したように、これら2つのドライバコンポーネントはそれぞれ2つの機能インタフェースを
持っています。上半分ドライバの場合は

* 上半分デバイスドライバは単一の標準ドライバインタフェースを公開します。**仮想ファイルシステム (VFS)**
  により、これもドライバ機能へのAPIを提供します。そして

* 下半分デバイスドライバにより管理されるMCU固有のハードウェアへの下半分のインタフェースの
  上半分側も提供します。

下半分ドライバは

* 上半分のドライバに対するインタフェースの下半分側と

* 下半分デバイスドライバにより管理されるハードウェアへの低レベルインターフェースを提供します。

一から多へ: カプセル化とポリモーフィズム
-------------------------------------------

これらのモジュール式の上半分ドライバと下半分ドライバには、ブジェクト指向設計に関連する
ある種の特性があります。カプセル化、データ抽象、ポリモーフィズムです。このカプセル化のため、
上半分ドライバは下半分ドライバの実装の詳細を知る必要はまったくありません。上半分ドライバと
下半分ドライバが統合するために必要なものはすべて、これら2つのドライバの間で定義された
インタフェースにより提供されます。実際、1つの上半分ドライバは1対多の関係で多数の下半分
ドライバインスタンスにサービスを提供することができます。

一例として、一部のMCUはUART、UARTとして機能するUSART、低電力UART (LPUART)、UARTとして
機能するその他の柔軟なデバイスをサポートしています。これらのそれぞれは ``arch/`` 配下の
適切な ``src/`` ディレクトリにある個別の下半分ドライバにより管理されます。さらに、ボードは
オフチップで外付けの 16550 UART ハードウェア (これは共通の下半分ドライバを持ちます) を持つ
ことができます。しかし、それらの全ては ``drivers/serial/serial.c`` にある一つの共通のシリアル
上半分ドライバでサポートされます。これは下半分ドライバ実装のオブジェクトライクな特性に
よってのみ可能になっています。